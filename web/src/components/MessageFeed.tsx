import { useEffect, useRef, useMemo, useState, useCallback } from "react";
import { ChevronRight, Clock, Plus, Terminal as TerminalIcon } from "lucide-react";
import { useStore } from "../store.js";
import { api } from "../api.js";
import { MessageBubble } from "./MessageBubble.js";
import { getToolIcon, getToolLabel, getPreview, ToolIcon } from "./ToolBlock.js";
import type { ChatMessage, ContentBlock, SdkSessionInfo } from "../types.js";
import { formatElapsed, formatTokenCount } from "../utils/format.js";
import { cn } from "@/lib/utils";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";

const FEED_PAGE_SIZE = 100;
const RESUME_HISTORY_PAGE_SIZE = 40;
const SCROLL_TOP_PREFETCH_PX = 120;
const savedDistanceFromBottomBySession = new Map<string, number>();

const EMPTY_MESSAGES: ChatMessage[] = [];
const EMPTY_SDK_SESSIONS: SdkSessionInfo[] = [];

function formatResumeSourcePath(path: string): string {
  const parts = path.split("/").filter(Boolean);
  if (parts.length === 0) return path;
  return parts.slice(-2).join("/");
}

// ─── Message-level grouping ─────────────────────────────────────────────────

interface ToolItem { id: string; name: string; input: Record<string, unknown> }

interface ToolMsgGroup {
  kind: "tool_msg_group";
  toolName: string;
  items: ToolItem[];
  firstId: string;
}

interface SubagentGroup {
  kind: "subagent";
  taskToolUseId: string;
  description: string;
  agentType: string;
  children: FeedEntry[];
}

type FeedEntry =
  | { kind: "message"; msg: ChatMessage }
  | ToolMsgGroup
  | SubagentGroup;

/**
 * Get the dominant tool name if this message is "tool-only"
 * (assistant message whose contentBlocks are ALL tool_use of the same name).
 * Returns null if it has text/thinking or mixed tool types.
 */
function getToolOnlyName(msg: ChatMessage): string | null {
  if (msg.role !== "assistant") return null;
  const blocks = msg.contentBlocks;
  if (!blocks || blocks.length === 0) return null;

  let toolName: string | null = null;
  for (const b of blocks) {
    if (b.type === "text" && b.text.trim()) return null;
    if (b.type === "thinking") return null;
    if (b.type === "tool_use") {
      if (toolName === null) toolName = b.name;
      else if (toolName !== b.name) return null;
    }
  }
  return toolName;
}

function extractToolItems(msg: ChatMessage): ToolItem[] {
  const blocks = msg.contentBlocks || [];
  return blocks
    .filter((b): b is ContentBlock & { type: "tool_use"; id: string; name: string; input: Record<string, unknown> } => b.type === "tool_use")
    .map((b) => ({ id: b.id, name: b.name, input: b.input }));
}

/** Get Task tool_use IDs from a feed entry */
function getTaskIdsFromEntry(entry: FeedEntry): string[] {
  if (entry.kind === "message") {
    const blocks = entry.msg.contentBlocks || [];
    return blocks
      .filter((b): b is Extract<ContentBlock, { type: "tool_use" }> => b.type === "tool_use")
      .filter(b => b.name === "Task")
      .map(b => b.id);
  }
  if (entry.kind === "tool_msg_group" && entry.toolName === "Task") {
    return entry.items.map(item => item.id);
  }
  return [];
}

/** Group consecutive same-tool messages */
function groupToolMessages(messages: ChatMessage[]): FeedEntry[] {
  const entries: FeedEntry[] = [];

  for (const msg of messages) {
    const toolName = getToolOnlyName(msg);

    if (toolName) {
      const last = entries[entries.length - 1];
      if (last?.kind === "tool_msg_group" && last.toolName === toolName) {
        last.items.push(...extractToolItems(msg));
        continue;
      }
      entries.push({
        kind: "tool_msg_group",
        toolName,
        items: extractToolItems(msg),
        firstId: msg.id,
      });
    } else {
      entries.push({ kind: "message", msg });
    }
  }

  return entries;
}

/** Build feed entries with subagent nesting */
function buildEntries(
  messages: ChatMessage[],
  taskInfo: Map<string, { description: string; agentType: string }>,
  childrenByParent: Map<string, ChatMessage[]>,
): FeedEntry[] {
  const grouped = groupToolMessages(messages);

  const result: FeedEntry[] = [];
  for (const entry of grouped) {
    result.push(entry);

    // After each entry containing Task tool_use(s), insert subagent groups
    const taskIds = getTaskIdsFromEntry(entry);
    for (const taskId of taskIds) {
      const children = childrenByParent.get(taskId);
      if (children && children.length > 0) {
        const info = taskInfo.get(taskId) || { description: "Subagent", agentType: "" };
        const childEntries = buildEntries(children, taskInfo, childrenByParent);
        result.push({
          kind: "subagent",
          taskToolUseId: taskId,
          description: info.description,
          agentType: info.agentType,
          children: childEntries,
        });
      }
    }
  }

  return result;
}

function groupMessages(messages: ChatMessage[]): FeedEntry[] {
  // Phase 1: Find all Task tool_use IDs across all messages
  const taskInfo = new Map<string, { description: string; agentType: string }>();
  for (const msg of messages) {
    if (!msg.contentBlocks) continue;
    for (const b of msg.contentBlocks) {
      if (b.type === "tool_use" && b.name === "Task") {
        const { input, id } = b;
        taskInfo.set(id, {
          description: String(input?.description || "Subagent"),
          agentType: String(input?.subagent_type || ""),
        });
      }
    }
  }

  // If no Task tool_uses found, skip the overhead
  if (taskInfo.size === 0) {
    return groupToolMessages(messages);
  }

  // Phase 2: Partition into top-level and child messages
  const childrenByParent = new Map<string, ChatMessage[]>();
  const topLevel: ChatMessage[] = [];

  for (const msg of messages) {
    if (msg.parentToolUseId && taskInfo.has(msg.parentToolUseId)) {
      let arr = childrenByParent.get(msg.parentToolUseId);
      if (!arr) { arr = []; childrenByParent.set(msg.parentToolUseId, arr); }
      arr.push(msg);
    } else {
      topLevel.push(msg);
    }
  }

  // Phase 3: Build grouped entries with subagent nesting
  return buildEntries(topLevel, taskInfo, childrenByParent);
}

// ─── Components ──────────────────────────────────────────────────────────────

function ToolMessageGroup({ group }: { group: ToolMsgGroup }) {
  const [open, setOpen] = useState(false);
  const iconType = getToolIcon(group.toolName);
  const label = getToolLabel(group.toolName);
  const count = group.items.length;

  // Single item — don't group, render inline
  if (count === 1) {
    const item = group.items[0];
    return (
      <div className="animate-[fadeSlideIn_0.2s_ease-out]">
        <div className="flex items-start gap-3">
          <AssistantAvatar />
          <div className="flex-1 min-w-0">
            <div className="border border-border rounded-[10px] overflow-hidden card-moku">
              <Button
                type="button"
                variant="ghost"
                size="sm"
                onClick={() => setOpen(!open)}
                className="h-auto w-full justify-start gap-2.5 rounded-none px-3 py-2 text-left hover:bg-accent/50"
              >
                <ChevronRight className={cn("size-3 text-muted-foreground transition-transform shrink-0", open && "rotate-90")} />
                <ToolIcon type={iconType} />
                <span className="text-xs font-medium text-foreground">{label}</span>
                <span className="text-xs text-muted-foreground truncate flex-1 font-mono">
                  {getPreview(item.name, item.input)}
                </span>
              </Button>
              {open && (
                <div className="px-3 pb-3 pt-0 border-t border-border mt-0">
                  <pre className="mt-2 text-[11px] text-muted-foreground font-mono whitespace-pre-wrap leading-relaxed max-h-60 overflow-y-auto">
                    {JSON.stringify(item.input, null, 2)}
                  </pre>
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Multi-item group
  return (
    <div className="animate-[fadeSlideIn_0.2s_ease-out]">
      <div className="flex items-start gap-3">
        <AssistantAvatar />
        <div className="flex-1 min-w-0">
          <div className="border border-border rounded-[10px] overflow-hidden card-moku">
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => setOpen(!open)}
              className="h-auto w-full justify-start gap-2.5 rounded-none px-3 py-2 text-left hover:bg-accent/50"
            >
              <ChevronRight className={cn("size-3 text-muted-foreground transition-transform shrink-0", open && "rotate-90")} />
              <ToolIcon type={iconType} />
              <span className="text-xs font-medium text-foreground">{label}</span>
              <Badge variant="secondary" className="text-[10px] tabular-nums px-1.5 py-0.5 h-auto">
                {count}
              </Badge>
            </Button>

            {open && (
              <div className="border-t border-border px-3 py-1.5">
                {group.items.map((item, i) => {
                  const preview = getPreview(item.name, item.input);
                  return (
                    <div key={item.id || i} className="flex items-center gap-2 py-1 text-xs text-muted-foreground font-mono truncate">
                      <span className="w-1 h-1 rounded-full bg-muted-foreground/40 shrink-0" />
                      <span className="truncate">{preview || JSON.stringify(item.input).slice(0, 80)}</span>
                    </div>
                  );
                })}
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}

function FeedEntries({ entries }: { entries: FeedEntry[] }) {
  return (
    <>
      {entries.map((entry, i) => {
        if (entry.kind === "tool_msg_group") {
          return <ToolMessageGroup key={entry.firstId || i} group={entry} />;
        }
        if (entry.kind === "subagent") {
          return <SubagentContainer key={entry.taskToolUseId} group={entry} />;
        }
        return <MessageBubble key={entry.msg.id} message={entry.msg} />;
      })}
    </>
  );
}

function SubagentContainer({ group }: { group: SubagentGroup }) {
  const [open, setOpen] = useState(false);
  const label = group.description || "Subagent";
  const agentType = group.agentType;
  const childCount = group.children.length;

  // Get the last visible entry for a compact preview
  const lastEntry = group.children[group.children.length - 1];
  const lastPreview = useMemo(() => {
    if (!lastEntry) return "";
    if (lastEntry.kind === "tool_msg_group") {
      return `${getToolLabel(lastEntry.toolName)}${lastEntry.items.length > 1 ? ` \u00d7${lastEntry.items.length}` : ""}`;
    }
    if (lastEntry.kind === "message" && lastEntry.msg.role === "assistant") {
      const text = lastEntry.msg.content?.trim();
      if (text) return text.length > 60 ? text.slice(0, 60) + "..." : text;
      const toolBlock = lastEntry.msg.contentBlocks?.find(
        (b): b is Extract<ContentBlock, { type: "tool_use" }> => b.type === "tool_use"
      );
      if (toolBlock) return getToolLabel(toolBlock.name);
    }
    return "";
  }, [lastEntry]);

  return (
    <div className="animate-[fadeSlideIn_0.2s_ease-out]">
      <div className="ml-10 border-l-2 border-primary/20 pl-4">
        <Button
          type="button"
          variant="ghost"
          size="sm"
          onClick={() => setOpen(!open)}
          className="mb-1 h-auto w-full justify-start gap-2 rounded-none px-0 py-1.5 text-left hover:bg-transparent"
        >
          <ChevronRight className={cn("size-3 text-muted-foreground transition-transform shrink-0", open && "rotate-90")} />
          <Clock className="size-3.5 text-primary shrink-0" />
          <span className="text-xs font-medium text-foreground truncate">{label}</span>
          {agentType && (
            <Badge variant="secondary" className="text-[10px] px-1.5 py-0.5 h-auto shrink-0">
              {agentType}
            </Badge>
          )}
          {!open && lastPreview && (
            <span className="text-[11px] text-muted-foreground truncate ml-1 font-mono">
              {lastPreview}
            </span>
          )}
          <Badge variant="secondary" className="text-[10px] tabular-nums px-1.5 py-0.5 h-auto shrink-0 ml-auto">
            {childCount}
          </Badge>
        </Button>

        {open && (
          <div className="space-y-3 pb-2">
            <FeedEntries entries={group.children} />
          </div>
        )}
      </div>
    </div>
  );
}

function AssistantAvatar() {
  return (
    <div className="w-7 h-7 rounded-full bg-primary/10 flex items-center justify-center shrink-0 mt-0.5">
      <svg viewBox="0 0 16 16" fill="currentColor" className="w-3.5 h-3.5 text-primary">
        <circle cx="8" cy="8" r="3" />
      </svg>
    </div>
  );
}

// ─── Main Feed ───────────────────────────────────────────────────────────────

export function MessageFeed({ sessionId }: { sessionId: string }) {
  const messages = useStore((s) => s.messages.get(sessionId) ?? EMPTY_MESSAGES);
  const sdkSession = useStore((s) => (s.sdkSessions || EMPTY_SDK_SESSIONS).find((session) => session.sessionId === sessionId));
  const streamingStartedAt = useStore((s) => s.streamingStartedAt.get(sessionId));
  const streamingOutputTokens = useStore((s) => s.streamingOutputTokens.get(sessionId));
  const sessionStatus = useStore((s) => s.sessionStatus.get(sessionId));
  const toolProgress = useStore((s) => s.toolProgress.get(sessionId));
  const bottomRef = useRef<HTMLDivElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const isNearBottom = useRef(true);
  const [elapsed, setElapsed] = useState(0);
  const [visibleCount, setVisibleCount] = useState(FEED_PAGE_SIZE);
  const [resumeHistoryMessages, setResumeHistoryMessages] = useState<ChatMessage[]>([]);
  const [resumeHistoryCursor, setResumeHistoryCursor] = useState(0);
  const [resumeHistoryHasMore, setResumeHistoryHasMore] = useState(false);
  const [resumeHistoryLoaded, setResumeHistoryLoaded] = useState(false);
  const [resumeHistoryLoading, setResumeHistoryLoading] = useState(false);
  const [resumeHistoryError, setResumeHistoryError] = useState("");
  const resumeHistoryMessageIdsRef = useRef<Set<string>>(new Set());
  const chatTabReentryTick = useStore((s) => s.chatTabReentryTickBySession.get(sessionId) ?? 0);
  const hasStreamingAssistant = useMemo(
    () => messages.some((m) => m.role === "assistant" && m.isStreaming),
    [messages],
  );
  const resumeSourceSessionId = useMemo(() => {
    if (sdkSession?.backendType === "codex") return "";
    return (sdkSession?.resumeSessionAt || "").trim();
  }, [sdkSession?.backendType, sdkSession?.resumeSessionAt]);
  const canLoadResumeHistory = resumeSourceSessionId.length > 0;
  const resumeModeLabel = sdkSession?.forkSession ? "Forked from" : "Continuing from";
  const mergedMessages = useMemo(() => {
    if (resumeHistoryMessages.length === 0) return messages;
    const deduped: ChatMessage[] = [];
    const seen = new Set<string>();
    for (const msg of resumeHistoryMessages) {
      if (seen.has(msg.id)) continue;
      seen.add(msg.id);
      deduped.push(msg);
    }
    for (const msg of messages) {
      if (seen.has(msg.id)) continue;
      seen.add(msg.id);
      deduped.push(msg);
    }
    return deduped;
  }, [resumeHistoryMessages, messages]);

  const grouped = useMemo(() => groupMessages(mergedMessages), [mergedMessages]);

  // Reset paging/transcript state when switching sessions.
  useEffect(() => {
    setVisibleCount(FEED_PAGE_SIZE);
    setResumeHistoryMessages([]);
    setResumeHistoryCursor(0);
    setResumeHistoryHasMore(false);
    setResumeHistoryLoaded(false);
    setResumeHistoryLoading(false);
    setResumeHistoryError("");
    resumeHistoryMessageIdsRef.current = new Set();
  }, [sessionId, resumeSourceSessionId]);

  const totalEntries = grouped.length;
  const hasMore = totalEntries > visibleCount;
  const visibleEntries = hasMore ? grouped.slice(totalEntries - visibleCount) : grouped;
  const hiddenCount = totalEntries - visibleEntries.length;

  const handleLoadMore = useCallback(() => {
    const el = containerRef.current;
    const prevHeight = el?.scrollHeight ?? 0;
    setVisibleCount((c) => c + FEED_PAGE_SIZE);
    // Preserve scroll position after DOM updates
    requestAnimationFrame(() => {
      if (el) {
        const newHeight = el.scrollHeight;
        el.scrollTop += newHeight - prevHeight;
      }
    });
  }, []);

  const loadResumeHistoryPage = useCallback(async (
    options: { preserveScroll?: boolean } = {},
  ) => {
    if (!canLoadResumeHistory || !resumeSourceSessionId || resumeHistoryLoading) return;

    const container = containerRef.current;
    const previousHeight = container?.scrollHeight ?? 0;
    const cursor = resumeHistoryLoaded ? resumeHistoryCursor : 0;

    setResumeHistoryLoading(true);
    setResumeHistoryError("");
    try {
      const page = await api.getClaudeSessionHistory(resumeSourceSessionId, {
        cursor,
        limit: RESUME_HISTORY_PAGE_SIZE,
      });

      const incoming = page.messages.map((msg): ChatMessage => ({
        id: msg.id,
        role: msg.role,
        content: msg.content,
        contentBlocks: msg.role === "assistant" ? msg.contentBlocks : undefined,
        timestamp: msg.timestamp || Date.now(),
        model: msg.role === "assistant" ? msg.model : undefined,
        stopReason: msg.role === "assistant" ? msg.stopReason : undefined,
      }));

      const uniqueIncoming: ChatMessage[] = [];
      for (const msg of incoming) {
        if (resumeHistoryMessageIdsRef.current.has(msg.id)) continue;
        resumeHistoryMessageIdsRef.current.add(msg.id);
        uniqueIncoming.push(msg);
      }

      setResumeHistoryMessages((prev) => [...uniqueIncoming, ...prev]);
      setResumeHistoryCursor(page.nextCursor);
      setResumeHistoryHasMore(page.hasMore);
      setResumeHistoryLoaded(true);

      if (uniqueIncoming.length > 0) {
        setVisibleCount((count) => count + uniqueIncoming.length);
      }

      if (options.preserveScroll !== false && container) {
        requestAnimationFrame(() => {
          const newHeight = container.scrollHeight;
          container.scrollTop += newHeight - previousHeight;
        });
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      setResumeHistoryError(message || "Failed to load previous history");
      if (!resumeHistoryLoaded) {
        setResumeHistoryMessages([]);
        setResumeHistoryCursor(0);
        setResumeHistoryHasMore(false);
      }
    } finally {
      setResumeHistoryLoading(false);
    }
  }, [
    canLoadResumeHistory,
    resumeSourceSessionId,
    resumeHistoryLoading,
    resumeHistoryLoaded,
    resumeHistoryCursor,
  ]);

  // Tick elapsed time every second while generating
  useEffect(() => {
    if (!streamingStartedAt && sessionStatus !== "running") {
      setElapsed(0);
      return;
    }
    const start = streamingStartedAt || Date.now();
    setElapsed(Date.now() - start);
    const interval = setInterval(() => setElapsed(Date.now() - start), 1000);
    return () => clearInterval(interval);
  }, [streamingStartedAt, sessionStatus]);

  function handleScroll() {
    const el = containerRef.current;
    if (!el) return;
    isNearBottom.current =
      el.scrollHeight - el.scrollTop - el.clientHeight < 120;
    const distanceFromBottom = Math.max(0, el.scrollHeight - el.clientHeight - el.scrollTop);
    savedDistanceFromBottomBySession.set(sessionId, distanceFromBottom);

    if (
      canLoadResumeHistory
      && resumeHistoryLoaded
      && resumeHistoryHasMore
      && !resumeHistoryLoading
      && el.scrollTop <= SCROLL_TOP_PREFETCH_PX
    ) {
      void loadResumeHistoryPage({ preserveScroll: true });
    }
  }

  const scrollToBottomInstant = useCallback(() => {
    const el = containerRef.current;
    if (!el) return;
    const previousBehavior = el.style.scrollBehavior;
    el.style.scrollBehavior = "auto";
    el.scrollTop = el.scrollHeight;
    el.style.scrollBehavior = previousBehavior;
  }, []);

  const restoreSavedScrollPosition = useCallback(() => {
    const el = containerRef.current;
    if (!el) return;
    const previousBehavior = el.style.scrollBehavior;
    el.style.scrollBehavior = "auto";
    const savedDistance = savedDistanceFromBottomBySession.get(sessionId);
    if (typeof savedDistance === "number") {
      el.scrollTop = Math.max(0, el.scrollHeight - el.clientHeight - savedDistance);
    } else {
      el.scrollTop = el.scrollHeight;
    }
    el.style.scrollBehavior = previousBehavior;
  }, [sessionId]);

  // On mount / session switch, restore previous reading position (or default to bottom).
  useEffect(() => {
    requestAnimationFrame(() => restoreSavedScrollPosition());
  }, [sessionId, restoreSavedScrollPosition]);

  // Persist the current scroll position for this session on unmount.
  useEffect(() => {
    return () => {
      const el = containerRef.current;
      if (!el) return;
      const distanceFromBottom = Math.max(0, el.scrollHeight - el.clientHeight - el.scrollTop);
      savedDistanceFromBottomBySession.set(sessionId, distanceFromBottom);
    };
  }, [sessionId]);

  // Only force bottom on explicit workspace tab switch back to chat.
  useEffect(() => {
    if (!chatTabReentryTick) return;
    requestAnimationFrame(() => scrollToBottomInstant());
  }, [chatTabReentryTick, scrollToBottomInstant]);

  useEffect(() => {
    if (isNearBottom.current) {
      bottomRef.current?.scrollIntoView({ behavior: "smooth" });
    }
  }, [messages]);

  if (mergedMessages.length === 0) {
    return (
      <div className="flex-1 flex flex-col items-center justify-center gap-4 select-none px-6">
        <div className="w-14 h-14 rounded-2xl card-moku border border-border flex items-center justify-center">
          <TerminalIcon className="size-7 text-muted-foreground" />
        </div>
        <div className="text-center">
          {canLoadResumeHistory ? (
            <>
              <p className="text-sm text-foreground font-medium mb-1">This session has prior Claude context</p>
              <p className="text-xs text-muted-foreground leading-relaxed mb-3">
                {resumeModeLabel} {resumeSourceSessionId.slice(0, 8)}. Load earlier messages into this chat when needed.
              </p>
              <Button
                variant="outline"
                size="sm"
                onClick={() => void loadResumeHistoryPage({ preserveScroll: false })}
                disabled={resumeHistoryLoading}
              >
                {resumeHistoryLoading ? "Loading..." : "Load previous history"}
              </Button>
              {resumeHistoryError && (
                <p className="text-xs text-destructive mt-2">{resumeHistoryError}</p>
              )}
            </>
          ) : (
            <>
              <p className="text-sm text-foreground font-medium mb-1">Start a conversation</p>
              <p className="text-xs text-muted-foreground leading-relaxed">
                Send a message to begin working with Moku.
              </p>
            </>
          )}
        </div>
      </div>
    );
  }

  return (
    <div className="flex-1 min-h-0 relative overflow-hidden">
      {/* Top fade — softens the scroll edge under the top bar */}
      <div className="pointer-events-none absolute top-0 inset-x-0 h-6 bg-gradient-to-b from-background to-transparent z-10" />
      <div
        ref={containerRef}
        onScroll={handleScroll}
        className="h-full overflow-y-auto overscroll-y-contain px-4 sm:px-6 py-5 sm:py-8"
      >
        <div className="max-w-3xl mx-auto space-y-5 sm:space-y-7">
          {canLoadResumeHistory && !resumeHistoryLoaded && (
            <div className="rounded-xl border border-border card-moku p-3">
              <div className="flex items-center justify-between gap-3">
                <div>
                  <p className="text-xs font-medium text-foreground">{resumeModeLabel} existing Claude thread</p>
                  <p className="text-[11px] text-muted-foreground mt-1">
                    {resumeSourceSessionId} {sdkSession?.cwd ? `\u00b7 ${formatResumeSourcePath(sdkSession.cwd)}` : ""}
                  </p>
                </div>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => void loadResumeHistoryPage({ preserveScroll: true })}
                  disabled={resumeHistoryLoading}
                  className="shrink-0"
                >
                  {resumeHistoryLoading ? "Loading..." : "Load previous history"}
                </Button>
              </div>
              {resumeHistoryError && (
                <p className="text-xs text-destructive mt-2">{resumeHistoryError}</p>
              )}
            </div>
          )}

          {canLoadResumeHistory && resumeHistoryLoaded && (
            <div className="flex justify-center">
              <p className="text-[11px] text-muted-foreground">
                {resumeHistoryHasMore
                  ? (resumeHistoryLoading
                    ? "Loading older transcript..."
                    : "Scroll to top to load older transcript")
                  : "Loaded all available prior transcript"}
              </p>
            </div>
          )}

          {hasMore && (
            <div className="flex justify-center pb-2">
              <Button
                variant="ghost"
                size="sm"
                onClick={handleLoadMore}
              >
                <Plus className="size-3" />
                Load {Math.min(FEED_PAGE_SIZE, hiddenCount)} more ({hiddenCount} hidden)
              </Button>
            </div>
          )}
          <FeedEntries entries={visibleEntries} />

          {/* Tool progress indicator */}
          {toolProgress && toolProgress.size > 0 && !hasStreamingAssistant && (
            <div className="flex items-center gap-1.5 text-[11px] text-muted-foreground font-mono pl-10">
              <span className="inline-block w-1.5 h-1.5 rounded-full bg-primary animate-pulse" />
              {Array.from(toolProgress.values()).map((p, i) => (
                <span key={i} className="flex items-center gap-1">
                  {i > 0 && <span className="text-muted-foreground/40">&middot;</span>}
                  <span>{getToolLabel(p.toolName)}</span>
                  <span className="text-muted-foreground/60">{p.elapsedSeconds}s</span>
                </span>
              ))}
            </div>
          )}

          {/* Generation stats bar */}
          {sessionStatus === "running" && elapsed > 0 && (
            <div className="flex items-center gap-1.5 text-[11px] text-muted-foreground font-mono pl-10">
              <span className="inline-block w-1.5 h-1.5 rounded-full bg-primary animate-pulse" />
              <span>Generating...</span>
              <span className="text-muted-foreground/60">(</span>
              <span>{formatElapsed(elapsed)}</span>
              {(streamingOutputTokens ?? 0) > 0 && (
                <>
                  <span className="text-muted-foreground/40">&middot;</span>
                  <span>&darr; {formatTokenCount(streamingOutputTokens!)}</span>
                </>
              )}
              <span className="text-muted-foreground/60">)</span>
            </div>
          )}

          <div ref={bottomRef} />
        </div>
      </div>
    </div>
  );
}
